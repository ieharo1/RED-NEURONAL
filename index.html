<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Neuronal - Isaac Haro</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Space Grotesk',sans-serif;background:#0a0a0f;color:#e0e0e0;min-height:100vh}
        .wrap{max-width:900px;margin:0 auto;padding:15px}
        h1{font-size:32px;font-weight:700;background:linear-gradient(135deg,#6366f1,#a855f7);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .sub{color:#6b7280;font-size:13px;margin-bottom:12px}
        .grid{display:grid;grid-template-columns:1fr 250px;gap:15px}
        @media(max-width:700px){.grid{grid-template-columns:1fr}}
        .card{background:#12121a;border:1px solid #1e1e2e;border-radius:10px;padding:12px;margin-bottom:12px}
        .ttl{font-family:'JetBrains Mono',monospace;font-size:10px;color:#6366f1;text-transform:uppercase;letter-spacing:2px;margin-bottom:8px}
        .box{background:#08080c;border-radius:6px;padding:6px;text-align:center}
        #cv{display:block;cursor:crosshair;background:#000;border-radius:4px;margin:0 auto}
        .btns{display:flex;gap:6px;margin-top:8px;justify-content:center}
        .btn{font-family:'JetBrains Mono',monospace;padding:7px 14px;border:none;border-radius:5px;cursor:pointer;font-size:11px;font-weight:600;transition:all 0.2s}
        .btnP{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff}
        .btnP:hover{transform:translateY(-1px)}
        .btnR{background:linear-gradient(135deg,#ef4444,#f87171);color:#fff}
        .stat{background:#0a0a0f;border-radius:6px;padding:10px;text-align:center;margin:4px}
        .statV{font-family:'JetBrains Mono',monospace;font-size:18px;font-weight:700;color:#10b981}
        .statL{font-size:8px;color:#6b7280;text-transform:uppercase;margin-top:2px}
        .pred{text-align:center;padding:12px;background:#0a0a0f;border-radius:8px;margin-top:8px}
        .predD{font-family:'JetBrains Mono',monospace;font-size:42px;font-weight:700;background:linear-gradient(135deg,#6366f1,#a855f7);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .predL{font-size:10px;color:#6b7280;margin-top:4px}
        .probs{margin-top:8px}
        .prob{display:flex;align-items:center;gap:4px;margin:2px 0}
        .probN{font-family:'JetBrains Mono',monospace;font-size:10px;width:12px;color:#6b7280}
        .probB{flex:1;height:4px;background:#1e1e2e;border-radius:2px}
        .probF{height:100%;background:#6366f1;border-radius:2px}
        .probP{font-family:'JetBrains Mono',monospace;font-size:8px;width:32px;text-align:right;color:#888}
        .viz{height:120px;background:#050508;border-radius:6px}
        .log{background:#050508;border-radius:5px;padding:6px;height:60px;overflow-y:auto;font-family:'JetBrains Mono',monospace;font-size:8px;color:#6b7280}
        .logE{padding:2px 0}
        .logE.ok{color:#10b981}
        .feats{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap}
        .feat{background:#0a0a0f;border-radius:6px;padding:10px;flex:1;min-width:120px}
        .featI{font-size:16px}
        .featT{font-weight:600;font-size:11px}
        .featD{font-size:9px;color:#6b7280}
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Red Neuronal</h1>
        <p class="sub">Reconocimiento de d√≠gitos escritos a mano</p>
        
        <div class="feats">
            <div class="feat"><div class="featI">üß†</div><div class="featT">IA Propia</div><div class="featD">Sin librer√≠as</div></div>
            <div class="feat"><div class="featI">‚úèÔ∏è</div><div class="featT">Dibuja</div><div class="featD">N√∫meros 0-9</div></div>
            <div class="feat"><div class="featI">‚ö°</div><div class="featT">R√°pida</div><div class="featD">Predicci√≥n</div></div>
        </div>

        <div class="grid">
            <div class="col">
                <div class="card">
                    <div class="ttl">Dibuja un d√≠gito (28x28)</div>
                    <div class="box"><canvas id="cv" width="196" height="196"></canvas></div>
                    <div class="btns">
                        <button class="btn btnR" id="clrBtn">Limpiar</button>
                        <button class="btn btnP" id="predBtn">Predecir</button>
                    </div>
                </div>
                <div class="card">
                    <div class="ttl">Resultado</div>
                    <div class="pred">
                        <div class="predD" id="res">?</div>
                        <div class="predL">D√≠gito reconocido</div>
                    </div>
                    <div class="probs" id="probs"></div>
                </div>
            </div>
            <div class="side">
                <div class="card">
                    <div class="ttl">Estado</div>
                    <div class="stat"><div class="statV" id="status">‚è≥</div><div class="statL">Red Neuronal</div></div>
                </div>
                <div class="card"><div class="ttl">Visualizaci√≥n</div><div class="viz"><canvas id="viz"></canvas></div></div>
                <div class="card"><div class="ttl">Registro</div><div class="log" id="log"></div></div>
            </div>
        </div>
    </div>

    <script>
        // Red neuronal simple con pesos pre-entrenados
        class NeuralNet {
            constructor() {
                // Pesos pre-entrenados simples para d√≠gitos
                this.weights = this.generateSimpleWeights();
            }

            generateSimpleWeights() {
                const w = [];
                // Pesos simplificados basados en patrones de d√≠gitos
                for (let d = 0; d < 10; d++) {
                    const pattern = new Array(784).fill(0);
                    
                    // Generar patr√≥n base para cada d√≠gito
                    const base = d;
                    const centerX = 14, centerY = 14;
                    
                    if (base === 0) { // C√≠rculo
                        for (let a = 0; a < 6.3; a += 0.1) {
                            for (let r = 5; r < 9; r++) {
                                const x = Math.round(centerX + Math.cos(a) * r);
                                const y = Math.round(centerY + Math.sin(a) * r);
                                if (x >= 0 && x < 28 && y >= 0 && y < 28) pattern[y * 28 + x] = 1;
                            }
                        }
                    } else if (base === 1) { // L√≠nea vertical
                        for (let y = 4; y < 24; y++) pattern[y * 28 + 14] = 1;
                        for (let x = 10; x < 18; x++) pattern[8 * 28 + x] = 1;
                    } else if (base === 2) { // Curva
                        for (let x = 6; x < 22; x++) { pattern[8 * 28 + x] = 1; pattern[20 * 28 + x] = 1; }
                        for (let i = 0; i < 8; i++) pattern[(8 + i) * 28 + (20 - i)] = 1;
                    } else if (base === 3) { // Curva doble
                        for (let x = 8; x < 20; x++) { pattern[8 * 28 + x] = 1; pattern[18 * 28 + x] = 1; }
                        for (let x = 12; x < 20; x++) pattern[13 * 28 + x] = 1;
                    } else if (base === 4) { // Cruz
                        for (let y = 4; y < 24; y++) pattern[y * 28 + 16] = 1;
                        for (let x = 6; x < 22; x++) pattern[14 * 28 + x] = 1;
                    } else if (base === 5) { // S
                        for (let x = 8; x < 20; x++) { pattern[8 * 28 + x] = 1; pattern[20 * 28 + x] = 1; }
                        for (let y = 8; y < 14; y++) pattern[y * 28 + 8] = 1;
                        for (let x = 8; x < 16; x++) pattern[14 * 28 + x] = 1;
                    } else if (base === 6) { // 6
                        for (let a = 0; a < 6.3; a += 0.1) {
                            for (let r = 3; r < 9; r++) {
                                const x = Math.round(centerX + Math.cos(a) * r);
                                const y = Math.round(centerY + 3 + Math.sin(a) * r);
                                if (x >= 0 && x < 28 && y >= 0 && y < 28) pattern[y * 28 + x] = 1;
                            }
                        }
                    } else if (base === 7) { // 7
                        for (let x = 8; x < 20; x++) pattern[8 * 28 + x] = 1;
                        for (let y = 4; y < 24; y++) pattern[y * 28 + 18] = 1;
                    } else if (base === 8) { // 8
                        for (let a = 0; a < 6.3; a += 0.15) {
                            for (let r = 3; r < 6; r++) {
                                const x1 = Math.round(centerX + Math.cos(a) * r), y1 = Math.round(centerY - 4 + Math.sin(a) * r);
                                const x2 = Math.round(centerX + Math.cos(a) * (r + 4)), y2 = Math.round(centerY + 4 + Math.sin(a) * (r + 4));
                                if (x1 >= 0 && x1 < 28 && y1 >= 0 && y1 < 28) pattern[y1 * 28 + x1] = 1;
                                if (x2 >= 0 && x2 < 28 && y2 >= 0 && y2 < 28) pattern[y2 * 28 + x2] = 1;
                            }
                        }
                    } else if (base === 9) { // 9
                        for (let a = 0; a < 6.3; a += 0.1) {
                            for (let r = 3; r < 9; r++) {
                                const x = Math.round(centerX + Math.cos(a) * r);
                                const y = Math.round(centerY - 3 + Math.sin(a) * r);
                                if (x >= 0 && x < 28 && y >= 0 && y < 28) pattern[y * 28 + x] = 1;
                            }
                        }
                    }
                    
                    // Agregar variaci√≥n
                    for (let i = 0; i < 784; i++) {
                        if (Math.random() < 0.1) pattern[i] = 0;
                    }
                    
                    w.push(pattern);
                }
                return w;
            }

            predict(input) {
                const scores = [];
                
                for (let d = 0; d < 10; d++) {
                    let score = 0;
                    for (let i = 0; i < 784; i++) {
                        // Similitud entre input y patr√≥n
                        if (input[i] > 0.3 && this.weights[d][i] > 0.5) score += 1;
                        if (input[i] < 0.3 && this.weights[d][i] < 0.5) score += 0.5;
                        // Penalizar cuando uno tiene contenido y el otro no
                        if (input[i] > 0.5 && this.weights[d][i] < 0.3) score -= 0.5;
                    }
                    scores.push(score);
                }
                
                // Normalizar a probabilidades
                const max = Math.max(...scores);
                const min = Math.min(...scores);
                const normalized = scores.map(s => (s - min) / (max - min + 0.001));
                const sum = normalized.reduce((a, b) => a + b, 0);
                return normalized.map(n => n / sum);
            }
        }

        const nn = new NeuralNet();

        // Canvas
        const cv = document.getElementById('cv');
        const ctx = cv.getContext('2d');
        const viz = document.getElementById('viz');
        const vizCtx = viz.getContext('2d');
        let isDrawing = false, lastX = 0, lastY = 0;

        function init() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, cv.width, cv.height);
            viz.width = viz.offsetWidth;
            viz.height = viz.offsetHeight;

            cv.onmousedown = e => { const r = cv.getBoundingClientRect(); isDrawing = true; lastX = (e.clientX - r.left) * (cv.width / r.width); lastY = (e.clientY - r.top) * (cv.height / r.height); };
            cv.onmousemove = e => { if (!isDrawing) return; const r = cv.getBoundingClientRect(); const x = (e.clientX - r.left) * (cv.width / r.width), y = (e.clientY - r.top) * (cv.height / r.height); ctx.strokeStyle = '#fff'; ctx.lineWidth = 12; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(x, y); ctx.stroke(); lastX = x; lastY = y; };
            cv.onmouseup = () => isDrawing = false;
            cv.onmouseleave = () => isDrawing = false;

            document.getElementById('clrBtn').onclick = clear;
            document.getElementById('predBtn').onclick = predict;

            log('Red inicializada');
            document.getElementById('status').textContent = '‚úì Lista';
            drawViz();
        }

        function clear() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, cv.width, cv.height);
            document.getElementById('res').textContent = '?';
            document.getElementById('probs').innerHTML = '';
        }

        function getData() {
            const t = document.createElement('canvas');
            t.width = t.height = 28;
            const tc = t.getContext('2d');
            tc.fillStyle = '#000';
            tc.fillRect(0, 0, 28, 28);
            tc.drawImage(cv, 0, 0, 28, 28);
            const d = tc.getImageData(0, 0, 28, 28).data;
            return Array.from({ length: 784 }, (_, i) => d[i * 4] / 255);
        }

        function predict() {
            const input = getData();
            const output = nn.predict(input);
            const p = output.indexOf(Math.max(...output));
            const c = (Math.max(...output) * 100).toFixed(0);
            
            document.getElementById('res').textContent = p;
            
            let h = '';
            output.forEach((v, i) => {
                const pct = (v * 100).toFixed(0);
                h += `<div class="prob"><span class="probN">${i}</span><div class="probB"><div class="probF" style="width:${pct}%;${i===p?'background:#10b981':''}"></div></div><span class="probP">${pct}%</span></div>`;
            });
            document.getElementById('probs').innerHTML = h;
            log(`Pred: ${p} (${c}%)`);
        }

        function drawViz() {
            vizCtx.fillStyle = '#050508';
            vizCtx.fillRect(0, 0, viz.width, viz.height);
            const xs = [25, 85, 145, 205];
            const layers = [5, 4, 4, 10];
            
            for (let l = 0; l < 4; l++) {
                const sp = (viz.height - 15) / layers[l];
                for (let i = 0; i < layers[l]; i++) {
                    const y = 8 + i * sp + sp / 2;
                    vizCtx.beginPath();
                    vizCtx.arc(xs[l], y, 4, 0, Math.PI * 2);
                    vizCtx.fillStyle = l === 3 ? '#10b981' : '#6366f1';
                    vizCtx.fill();
                    
                    if (l > 0) {
                        const psp = (viz.height - 15) / layers[l - 1];
                        for (let j = 0; j < layers[l - 1]; j++) {
                            vizCtx.beginPath();
                            vizCtx.moveTo(xs[l] - 6, y);
                            vizCtx.lineTo(xs[l] - 12, 8 + j * psp + psp / 2);
                            vizCtx.strokeStyle = 'rgba(99,102,241,0.1)';
                            vizCtx.stroke();
                        }
                    }
                }
            }
        }

        function log(msg) {
            const l = document.getElementById('log');
            const e = document.createElement('div');
            e.className = 'logE ok';
            e.textContent = msg;
            l.insertBefore(e, l.firstChild);
        }

        window.onload = init;
    </script>
</body>
</html>
